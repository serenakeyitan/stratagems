{
  "address": "0x8dcdc0bd18cf4c7da4f719a6038f5c4b03ce1e7b",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract TestTokens",
          "name": "tokensToMint",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "tokens",
      "outputs": [
        {
          "internalType": "contract TestTokens",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "topup",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "contractName": "TestTokensInfiniteDistributor",
  "sourceName": "src/test/TestTokensInfiniteDistributor.sol",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161020a38038061020a83398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b60805161017a61009060003960008181604a015260d1015261017a6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806369774c2d1461003b5780639d63848a14610045575b600080fd5b610043610095565b005b61006c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6040517f40c10f1900000000000000000000000000000000000000000000000000000000815233600482015267d02ab486cedc000060248201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f1990604401600060405180830381600087803b15801561012a57600080fd5b505af115801561013e573d6000803e3d6000fd5b5050505056fea2646970667358221220217b750f6d0c4a1482cd3bb45b9b6de9056731eef213aeb521356b30e489eccd64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806369774c2d1461003b5780639d63848a14610045575b600080fd5b610043610095565b005b61006c7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6040517f40c10f1900000000000000000000000000000000000000000000000000000000815233600482015267d02ab486cedc000060248201527f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906340c10f1990604401600060405180830381600087803b15801561012a57600080fd5b505af115801561013e573d6000803e3d6000fd5b5050505056fea2646970667358221220217b750f6d0c4a1482cd3bb45b9b6de9056731eef213aeb521356b30e489eccd64736f6c63430008140033",
  "linkReferences": {},
  "deployedLinkReferences": {},
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "evm": {
    "gasEstimates": {
      "creation": {
        "codeDepositCost": "75600",
        "executionCost": "infinite",
        "totalCost": "infinite"
      },
      "external": {
        "tokens()": "infinite",
        "topup()": "infinite"
      }
    }
  },
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract TestTokens\",\"name\":\"tokensToMint\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract TestTokens\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/test/TestTokensInfiniteDistributor.sol\":\"TestTokensInfiniteDistributor\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"solidity-kit/solc_0.8/ERC20/ERC2612/implementations/UsingPermit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../implementations/ImplementingERC20Internal.sol\\\";\\nimport \\\"../interfaces/IERC2612.sol\\\";\\nimport \\\"../../../ERC712/implementations/UsingERC712.sol\\\";\\nimport \\\"../../../ERC712/implementations/ImplementingExternalDomainSeparator.sol\\\";\\n\\nabstract contract UsingPermit is ImplementingERC20Internal, ImplementingExternalDomainSeparator, UsingERC712, IERC2612 {\\n    bytes32 internal constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    mapping(address => uint256) internal _nonces;\\n\\n    /// @inheritdoc IERC2612\\n    function nonces(address owner) external view returns (uint256) {\\n        return _nonces[owner];\\n    }\\n\\n    /// @inheritdoc IERC2612\\n    function DOMAIN_SEPARATOR()\\n        public\\n        view\\n        virtual\\n        override(IERC2612, ImplementingExternalDomainSeparator)\\n        returns (bytes32);\\n\\n    /// @inheritdoc IERC2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        if (owner == address(0)) {\\n            revert InvalidAddress(address(0));\\n        }\\n\\n        uint256 currentNonce = _nonces[owner];\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentNonce, deadline))\\n            )\\n        );\\n        if (owner != ecrecover(digest, v, r, s)) {\\n            revert InvalidSignature();\\n        }\\n        if (deadline != 0 && block.timestamp > deadline) {\\n            revert DeadlineOver(block.timestamp, deadline);\\n        }\\n\\n        _nonces[owner] = currentNonce + 1;\\n        _approveFor(owner, spender, value);\\n    }\\n}\\n\",\"keccak256\":\"0xbda75beb4b62d68a9f237eebe563d3e24f9a43d59d474b0cfc72b6e249e997b8\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/implementations/UsingPermitWithDynamicChainID.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingPermit.sol\\\";\\nimport \\\"../../../ERC712/implementations/UsingERC712WithDynamicChainID.sol\\\";\\n\\nabstract contract UsingPermitWithDynamicChainID is UsingPermit, UsingERC712WithDynamicChainID {\\n    constructor(address verifyingContract) UsingERC712WithDynamicChainID(verifyingContract) {}\\n\\n    /// @inheritdoc IERC2612\\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32) {\\n        return _currentDomainSeparator();\\n    }\\n}\\n\",\"keccak256\":\"0xc57cea8c9d67062894cfffd755a82007f0730388a35b612bed0dfd747e3b7070\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/ERC2612/interfaces/IERC2612.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC2612 {\\n    /// @notice The signature do not match the expected signer\\n    error InvalidSignature();\\n    /// @notice The permit has expired\\n    /// @param currentTime time at which the error happen\\n    /// @param deadline the deadline\\n    error DeadlineOver(uint256 currentTime, uint256 deadline);\\n\\n    /// @notice allow `spender` to spend `value` amount of token on behalf of `owner`\\n    /// @param owner owner of the tokens\\n    /// @param spender address allowed to spend on behalf of the owner.\\n    /// @param value amount of token allowed to be spent\\n    /// @param deadline timestamp in seconds after which the permit is not valid.\\n    /// @param v signature part v\\n    /// @param r signature part r\\n    /// @param s signature part s\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice return the current nonce of the owner\\n    /// @param owner address queried\\n    /// @return nonce nonce value\\n    function nonces(address owner) external view returns (uint256 nonce);\\n\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x4cfe3a61d7721761dd90ceb55c77d5d7ecaeb153d567c40d3b5ca33e266df2ea\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/implementations/ERC20Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20WithCallback.sol\\\";\\nimport \\\"../interfaces/IERC20WithDistribution.sol\\\";\\nimport \\\"./ImplementingERC20Internal.sol\\\";\\nimport \\\"../../utils/Constants.sol\\\";\\n\\nabstract contract ERC20Base is IERC20, IERC20WithCallback, IERC20WithDistribution, ImplementingERC20Internal {\\n    uint256 internal _totalSupply;\\n    mapping(address => uint256) internal _balances;\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\n\\n    /// @inheritdoc IERC20\\n    function totalSupply() external view override returns (uint256) {\\n        return _internal_totalSupply();\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        if (owner == address(this)) {\\n            // see transferFrom: address(this) allows anyone\\n            return type(uint256).max;\\n        }\\n        return _allowances[owner][spender];\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function decimals() external pure virtual override returns (uint8) {\\n        return uint8(18);\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function transfer(address to, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20WithDistribution\\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        to.transfer(msg.value);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20WithDistribution\\n    function distributeAlongWithETH(address payable[] memory tos, uint256 totalAmount) external payable returns (bool) {\\n        uint256 val = msg.value / tos.length;\\n        if (msg.value != val * tos.length) {\\n            revert InvalidMsgValue(msg.value, val * tos.length);\\n        }\\n        uint256 amount = totalAmount / tos.length;\\n        if (totalAmount != amount * tos.length) {\\n            revert InvalidTotalAmount(totalAmount, amount * tos.length);\\n        }\\n        for (uint256 i = 0; i < tos.length; i++) {\\n            _transfer(msg.sender, tos[i], amount);\\n            tos[i].transfer(val);\\n        }\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20WithCallback\\n    function transferAndCall(\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, amount, data);\\n    }\\n\\n    /// @inheritdoc IERC20WithCallback\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transferFrom(from, to, amount);\\n        return ITransferReceiver(to).onTokenTransfer(from, amount, data);\\n    }\\n\\n    /// @inheritdoc IERC20WithCallback\\n    function transferOnBehalfAndCall(\\n        address forAddress,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _transfer(msg.sender, to, amount);\\n        return ITransferOnBehalfReceiver(to).onTokenTransferedOnBehalf(msg.sender, forAddress, amount, data);\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transferFrom(from, to, amount);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approveFor(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC20WithCallback\\n    function approveAndCall(\\n        address spender,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool) {\\n        _approveFor(msg.sender, spender, amount);\\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, amount, data);\\n    }\\n\\n    // ------------------------------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // ------------------------------------------------------------------------------------------------------------------\\n\\n    function _internal_totalSupply() internal view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function _approveFor(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        if (owner == address(0) || spender == address(0)) {\\n            revert InvalidAddress(address(0));\\n        }\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // anybody can transfer from this\\n        // this allow mintAndApprovedCall without gas overhead\\n        if (msg.sender != from && from != address(this)) {\\n            uint256 currentAllowance = _allowances[from][msg.sender];\\n            if (currentAllowance != type(uint256).max) {\\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\\n                if (currentAllowance < amount) {\\n                    revert NotAuthorizedAllowance(currentAllowance, amount);\\n                }\\n                _allowances[from][msg.sender] = currentAllowance - amount;\\n            }\\n        }\\n        _transfer(from, to, amount);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        if (to == address(0) || to == address(this)) {\\n            revert InvalidAddress(to);\\n        }\\n        uint256 currentBalance = _balances[from];\\n        if (currentBalance < amount) {\\n            revert NotEnoughTokens(currentBalance, amount);\\n        }\\n        _balances[from] = currentBalance - amount;\\n        _balances[to] += amount;\\n        emit Transfer(from, to, amount);\\n    }\\n\\n    function _transferAllIfAny(address from, address to) internal {\\n        uint256 balanceLeft = _balances[from];\\n        if (balanceLeft > 0) {\\n            _balances[from] = 0;\\n            _balances[to] += balanceLeft;\\n            emit Transfer(from, to, balanceLeft);\\n        }\\n    }\\n\\n    function _mint(address to, uint256 amount) internal override {\\n        _totalSupply += amount;\\n        _balances[to] += amount;\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burnFrom(address from, uint256 amount) internal override {\\n        uint256 currentBalance = _balances[from];\\n        if (currentBalance < amount) {\\n            revert NotEnoughTokens(currentBalance, amount);\\n        }\\n        _balances[from] = currentBalance - amount;\\n        _totalSupply -= amount;\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x70a09206867ba59731583f5a4bbd218687e621be2eb850c489a7f2dc94f65b36\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/implementations/ImplementingERC20Internal.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingERC20Internal {\\n    function _approveFor(\\n        address owner,\\n        address target,\\n        uint256 amount\\n    ) internal virtual;\\n\\n    function _mint(address to, uint256 amount) internal virtual;\\n\\n    function _burnFrom(address from, uint256 amount) internal virtual;\\n\\n    function _internal_totalSupply() internal view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x7fffe7ccac2572bd35289bcf08c7d1ad9efbbfe1412c20190899cc93e8f9888b\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20Errors.sol\\\";\\n\\ninterface IERC20 {\\n    /// @notice trigger when tokens are transferred, including zero value transfers.\\n    /// @param from the account the tokens are sent from\\n    /// @param to the account the tokens are sent to\\n    /// @param value number of tokens sent\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /// @notice trigger on approval amount being set.\\n    ///   Note that Transfer events need to be considered to compute the current allowance.\\n    /// @param owner the account approving the `spender`\\n    /// @param spender the account allowed to spend\\n    /// @param value the amount granted\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice Returns the total token supply.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @notice Returns the number of decimals the token uses.\\n    function decimals() external view returns (uint8);\\n\\n    /// @notice Returns the symbol of the token.\\n    function symbol() external view returns (string memory);\\n\\n    /// @notice Returns the name of the token.\\n    function name() external view returns (string memory);\\n\\n    /// @notice Returns the account balance of another account with address `owner`.\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    /// @notice Transfers `amount` of tokens to address `to`.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /// @notice Returns the amount which `spender` is still allowed to withdraw from `owner`.\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /// @notice Allows `spender` to withdraw from your account multiple times, up to `amount`.\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /// @notice Transfers `amount` tokens from address `from` to address `to`.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x15bb1e4e1340b29eefc06b8826fcf9e6455e25ba972709672da7d3788777133f\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20Errors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @notice The msg value do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidMsgValue(uint256 provided, uint256 expected);\\n/// @notice The total amount provided do not match the expected value\\n/// @param provided msg.value amount provided\\n/// @param expected value expected\\nerror InvalidTotalAmount(uint256 provided, uint256 expected);\\n/// @notice An invalid address is specified (for example: zero address)\\n/// @param addr invalid address\\nerror InvalidAddress(address addr);\\n/// @notice the amount requested exceed the allowance\\n/// @param currentAllowance the current allowance\\n/// @param expected amount expected\\nerror NotAuthorizedAllowance(uint256 currentAllowance, uint256 expected);\\n/// @notice the amount requested exceed the balance\\n/// @param currentBalance the current balance\\n/// @param expected amount expected\\nerror NotEnoughTokens(uint256 currentBalance, uint256 expected);\\n\",\"keccak256\":\"0xc8ab4cfee19338da32d2fc5473e1ee740bf608c59196ebd16de74294c4813ae9\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20WithCallback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\ninterface ITransferReceiver {\\n    /// @notice called by ERC20 token after transfer been executed.\\n    /// @param payer account sending the money\\n    /// @param amount number of token transfered\\n    /// @param data extra data\\n    function onTokenTransfer(\\n        address payer,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\ninterface ITransferOnBehalfReceiver {\\n    /// @notice called by ERC20 token after transfer been executed.\\n    /// @param payer account sending the money\\n    /// @param forAddress account to be considered as te actual payer\\n    /// @param amount number of token transfered\\n    /// @param data extra data\\n    function onTokenTransferedOnBehalf(\\n        address payer,\\n        address forAddress,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\ninterface IApprovalReceiver {\\n    /// @notice called by ERC20 token after transfer been executed.\\n    /// @param owner account that grant the approval\\n    /// @param amount number of token approved\\n    /// @param data extra data\\n    function onTokenApproval(\\n        address owner,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\\ninterface IERC20WithCallback is IERC20 {\\n    /// @notice transfer `amount` token to `to` and callback into it via `onTokenTransfer`\\n    /// @param to account to receive the tokens\\n    /// @param amount number of token to transfer\\n    /// @param data extra data\\n    /// @return success\\n    function transferAndCall(\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    /// @notice transfer `amount` token to `to` and callback into it via `onTokenTransfer`\\n    /// @param from account to send the token from\\n    /// @param to account to receive the tokens\\n    /// @param amount number of token to transfer\\n    /// @param data extra data\\n    /// @return success\\n    function transferFromAndCall(\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    /// @notice transfer `amount` token to `to` and callback into it via `onTokenTransferedOnBehalf`\\n    /// @param forAddress account to send the token for\\n    /// @param to account to receive the tokens\\n    /// @param amount number of token to transfer\\n    /// @param data extra data\\n    /// @return success\\n    function transferOnBehalfAndCall(\\n        address forAddress,\\n        address to,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n\\n    /// @notice approve `amount` token to be spent by `spender` and callback into it via `onTokenApproval`\\n    /// @param spender account to send the token for\\n    /// @param amount number of token to transfer\\n    /// @param data extra data\\n    /// @return success\\n    function approveAndCall(\\n        address spender,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0xabb97c4b378714887c6f0fecaa10b556bffba476e6b25b9a36ed2abb0b02d9b2\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC20/interfaces/IERC20WithDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\ninterface IERC20WithDistribution is IERC20 {\\n    /// @notice transfer\\n    function transferAlongWithETH(address payable to, uint256 amount) external payable returns (bool);\\n\\n    /// @notice distribute\\n    function distributeAlongWithETH(address payable[] memory tos, uint256 totalAmount) external payable returns (bool);\\n}\\n\",\"keccak256\":\"0xab396b9f4c7e3009962cfb59c7d4a15654ce96aa048d8b28c3a9c1b5c510b8fa\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC712/implementations/ImplementingExternalDomainSeparator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract ImplementingExternalDomainSeparator {\\n    /// @notice EIP-712 Domain separator hash\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32);\\n}\\n\",\"keccak256\":\"0x69d5b0be646e03a444a7acd0721c252c4ff7a4ad583eefc3a040be512988a2f8\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC712/implementations/Named.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract Named {\\n    /// @notice Returns the name of the contract.\\n    function name() public view virtual returns (string memory);\\n}\\n\",\"keccak256\":\"0x869e27f3df5dc2f19733c1c218bb479324fd108f3be79509b3125a45728b3127\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC712/implementations/UsingERC712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC5267.sol\\\";\\n\\nabstract contract UsingERC712 is IERC5267 {}\\n\",\"keccak256\":\"0x5b2d5c3dd2ebe8dedf66a6d1a8b01918a42dfe3bc00778dca06fdf7686b7699e\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC712/implementations/UsingERC712WithDynamicChainID.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UsingERC712.sol\\\";\\nimport \\\"./Named.sol\\\";\\n\\nabstract contract UsingERC712WithDynamicChainID is UsingERC712, Named {\\n    uint256 private immutable _deploymentChainID;\\n    bytes32 private immutable _deploymentDomainSeparator;\\n    address private immutable _verifyingContract;\\n\\n    /// @dev we let you specifying the verifying contract so that if you use a proxy, the implementation can use it.\\n    constructor(address verifyingContract) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        _deploymentChainID = chainID;\\n        _verifyingContract = verifyingContract == address(0) ? address(this) : verifyingContract;\\n        _deploymentDomainSeparator = _calculateDomainSeparator(chainID, _verifyingContract);\\n    }\\n\\n    /// @inheritdoc IERC5267\\n    function eip712Domain()\\n        external\\n        view\\n        virtual\\n        override\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainID,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        )\\n    {\\n        fields = 0x0D;\\n        name = _name();\\n        version = \\\"\\\";\\n        assembly {\\n            chainID := chainid()\\n        }\\n        verifyingContract = _verifyingContract;\\n        salt = 0;\\n        extensions = new uint256[](0);\\n    }\\n\\n    // ------------------------------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // ------------------------------------------------------------------------------------------------------------------\\n\\n    // need to ensure we can use return value \\\"name\\\" in `eip712Domain`\\n    function _name() internal view returns (string memory) {\\n        return name();\\n    }\\n\\n    function _currentDomainSeparator() internal view returns (bytes32) {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        // in case a fork happen, to support the chain that had to change its chainID, we compute the domain operator\\n        return\\n            chainID == _deploymentChainID\\n                ? _deploymentDomainSeparator\\n                : _calculateDomainSeparator(chainID, _verifyingContract);\\n    }\\n\\n    /// @dev Calculate the Domain Separator used to compute ERC712 hash\\n    function _calculateDomainSeparator(uint256 chainID, address verifyingContract) private view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name())),\\n                    chainID,\\n                    verifyingContract\\n                )\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x016069b6dc537b56b9814f8d2ab4b020fe54d89ed769ed31f7ef41fc21c814ac\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/ERC712/interfaces/IERC5267.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC5267 {\\n    /// @notice The return values of this function MUST describe the domain separator that is used for verification of EIP-712 signatures in the contract. They describe both the form of the EIP712Domain struct (i.e., which of the optional fields and extensions are present) and the value of each field, as follows.\\n    /// @return fields A bit map where bit i is set to 1 if and only if domain field i is present (0 \\u2264 i \\u2264 4). Bits are read from least significant to most significant, and fields are indexed in the order that is specified by EIP-712, identical to the order in which they are listed in the function type.\\n    /// @return name EIP-712 name\\n    /// @return version EIP-712 version\\n    /// @return chainID EIP-712 chainID\\n    /// @return verifyingContract EIP-712 name verifyingContract\\n    /// @return salt EIP-712 salt\\n    /// @return extensions A list of EIP numbers that specify additional fields in the domain. The method to obtain the value for each of these additional fields and any conditions for inclusion are expected to be specified in the respective EIP. The value of fields does not affect their inclusion.\\n    function eip712Domain()\\n        external\\n        view\\n        returns (\\n            bytes1 fields,\\n            string memory name,\\n            string memory version,\\n            uint256 chainID,\\n            address verifyingContract,\\n            bytes32 salt,\\n            uint256[] memory extensions\\n        );\\n}\\n\",\"keccak256\":\"0x75dbdd71145fe826e2d2ee7b1f251e486b84923790162e7367550c98f48bc40d\",\"license\":\"MIT\"},\"solidity-kit/solc_0.8/utils/Constants.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Constants {\\n    uint256 internal constant DECIMALS_18 = 1000000000000000000;\\n}\\n\",\"keccak256\":\"0x6dd387f2cec5f9f1a1d13d5e8658f7fa96e20a89c1030295c6d663bf17fc0dc7\",\"license\":\"MIT\"},\"src/test/TestTokens.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"solidity-kit/solc_0.8/ERC20/implementations/ERC20Base.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC20/ERC2612/implementations/UsingPermitWithDynamicChainID.sol\\\";\\nimport \\\"solidity-kit/solc_0.8/ERC20/ERC2612/implementations/UsingPermitWithDynamicChainID.sol\\\";\\n\\ncontract TestTokens is ERC20Base, UsingPermitWithDynamicChainID {\\n    error NotAuthorized();\\n\\n    event MinterAuthorized(address indexed account, bool authorized);\\n\\n    Config public config;\\n\\n    mapping(address => bool) public authorizedMinters;\\n\\n    struct Config {\\n        address admin;\\n    }\\n\\n    constructor(address to, uint256 amount, Config memory initialConfig) UsingPermitWithDynamicChainID(address(this)) {\\n        config = initialConfig;\\n        _mint(to, amount);\\n        _authorizeMinter(initialConfig.admin, true);\\n    }\\n\\n    string public constant symbol = \\\"TOKEN\\\";\\n\\n    function name() public pure override(IERC20, Named) returns (string memory) {\\n        return \\\"Tokens\\\";\\n    }\\n\\n    function setConfig(Config memory newConfig) external {\\n        if (msg.sender != config.admin) {\\n            revert NotAuthorized();\\n        }\\n        config = newConfig;\\n    }\\n\\n    function authorizeMinters(address[] calldata accounts, bool authorized) external {\\n        if (msg.sender != config.admin) {\\n            revert NotAuthorized();\\n        }\\n        for (uint256 i = 0; i < accounts.length; i++) {\\n            _authorizeMinter(accounts[i], authorized);\\n        }\\n    }\\n\\n    function mint(address to, uint256 amount) external {\\n        if (!authorizedMinters[msg.sender]) {\\n            revert NotAuthorized();\\n        }\\n        _mint(to, amount);\\n    }\\n\\n    // --------------------------------------------------------------------------------------------\\n    // INTERNALS\\n    // --------------------------------------------------------------------------------------------\\n\\n    function _authorizeMinter(address account, bool authorized) internal {\\n        authorizedMinters[account] = authorized;\\n        emit MinterAuthorized(account, authorized);\\n    }\\n}\\n\",\"keccak256\":\"0x51f957a4a9206fbfca4213f1a93ae1a8fe0fe51cc602d6fab8d2b1e67865bba2\",\"license\":\"AGPL-3.0\"},\"src/test/TestTokensInfiniteDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TestTokens.sol\\\";\\n\\ncontract TestTokensInfiniteDistributor {\\n    TestTokens public immutable tokens;\\n\\n    constructor(TestTokens tokensToMint) {\\n        tokens = tokensToMint;\\n    }\\n\\n    function topup() external {\\n        tokens.mint(msg.sender, 15 ether);\\n    }\\n}\\n\",\"keccak256\":\"0xea7103d7db0ae85d5946e7e13ddd76af0452c96fde73aed41f5b341cc6d40a2c\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "storageLayout": {
    "storage": [],
    "types": null
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "argsData": "0x0000000000000000000000002d1ecf0a44b19d23cfac37f1ce2399571ed4f7ba",
  "transaction": {
    "hash": "0xb0ab713a77874520643c2224709d2e166a20a55caa4f6c794b42dbd974a4a849",
    "nonce": "0xe1",
    "origin": "0x61c461ecc993aadeb7e4b47e96d1b8cc37314b20"
  },
  "receipt": {
    "confirmations": 0,
    "blockHash": "0x23b91202e935d19f906e364e783798a73ca454d6f7a33726f58142ad8e7b43a2",
    "blockNumber": "0x49c061",
    "transactionIndex": "0x33"
  }
}